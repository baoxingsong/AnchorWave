/*
 * =====================================================================================
 *
 *       Filename:  controlLayer.cpp
 *
 *    Description:
 *
 *        Version:  1.0
 *        Created:  09/25/2020 09:38:26
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Baoxing Song (songbx.me), songbaoxing168@163.com
 *
 * =====================================================================================
 */

#include "controlLayer.h"


int gff2seq(int argc, char **argv, std::map<std::string, std::string> &parameters) {
    std::stringstream usage;
    usage << "Usage: " << PROGRAMNAME << " gff2seq -i inputGffFile -r inputGenome -o outputSequences " << std::endl <<
          "Options" << std::endl <<
          " -h        produce help message" << std::endl <<
          " -i FILE   reference genome annotation in GFF/GTF format" << std::endl <<
          " -r FILE   reference genome sequence in fasta format" << std::endl <<
          " -o FILE   output file of the longest CDS/exon for each gene" << std::endl <<
          " -x        use exon records instead of CDS from the GFF file" << std::endl <<
          " -m INT    minimum exon length to output (default: 20)" << std::endl << std::endl;

    InputParser inputParser(argc, argv);
    if (inputParser.cmdOptionExists("-h") || inputParser.cmdOptionExists("--help")) {
        std::cerr << usage.str();
    } else if (inputParser.cmdOptionExists("-i") && inputParser.cmdOptionExists("-r") && inputParser.cmdOptionExists("-o")) {
        std::string inputGffFile = inputParser.getCmdOption("-i");
        std::string genome = inputParser.getCmdOption("-r");
        std::string outputCdsSequences = inputParser.getCmdOption("-o");

        int minExon;
        if (inputParser.cmdOptionExists("-m")) {
            minExon = std::stoi(inputParser.getCmdOption("-m"));
        } else {
            minExon = 20;
        }
        bool exonModel = false;
        if (inputParser.cmdOptionExists("-x")) {
            exonModel = true;
        }
        getSequences(inputGffFile, genome, outputCdsSequences, parameters, minExon, exonModel);
        return 0;
    } else {
        std::cerr << usage.str();
    }
    return 0;
}


int genomeAlignment(int argc, char **argv, std::map<std::string, std::string> &parameters) {
    std::stringstream usage;

    int32_t matchingScore = 0;
    int32_t mismatchingPenalty = -6;
    int32_t openGapPenalty1 = -8;
    int32_t extendGapPenalty1 = -2;

    int32_t openGapPenalty2 = -75;
    int32_t extendGapPenalty2 = -1;

    int minExon = 20;
    double minimumSimilarity = 0.95;
    double minimumSimilarity2 = 0.2;

    double inversion_PENALTY = -1;
//    double MIN_ALIGNMENT_SCORE = 3000; // to be optimized
    double MIN_ALIGNMENT_SCORE = 2;
    bool considerInversion = false;
    int32_t wfaSize = 15000;
    int32_t wfaSize2 = 50000;
    int32_t wfaSize3 = 200000; // if the inter-anchor length is shorter than this value, stop trying to find new anchors
    int64_t windownWidth = 38000;
    int expectedCopies = 1;
    double maximumSimilarity = 0.6; // the maximum simalarity between secondary hist the primary hit. If the second hit is too similary with primary hit, that is unwanted duplications

    int32_t min_wavefront_length = 20;
    int32_t max_distance_threshold = 100;

    int32_t seed_window_size = 38;
    int32_t mini_cns_score = 30;
    int32_t step_size = 8;
    int32_t matrix_boundary_distance = 0;
    bool searchForNewAnchors = true;

    int k = 12;
    int mw = 1;
    bool H = false;

    int32_t scoreThreshold = 54;
    int32_t w2 = 10;  //this is the band width for band sequence alignments
    int32_t xDrop = 20;
    int threads = 1;
    bool exonModel = false;

    usage << "Usage: " << PROGRAMNAME
          << " genoAli -i refGffFile -r refGenome -a cds.sam -as cds.fa -ar ref.sam -s targetGenome -n outputAnchorFile -o output.maf -f output.fragmentation.maf " << std::endl <<
          "Options" << std::endl <<
          " -h           produce help message" << std::endl <<
          " -i   FILE    reference GFF/GTF file" << std::endl <<
          " -r   FILE    reference genome sequence file in fasta format" << std::endl <<
          " -as  FILE    anchor sequence file. (output from the gff2seq command)" << std::endl <<
          " -a   FILE    sam file generated by mapping conserved sequence to query genome" << std::endl <<
          " -s   FILE    target genome sequence file in fasta format" << std::endl <<
          "              Those sequences with the same name in the reference genome and query genome file would be aligned" << std::endl <<
          " -n   FILE    output anchors file" << std::endl <<
          " -o   FILE    output file in maf format" << std::endl <<
          " -f   FILE    output sequence alignment for each anchor/inter-anchor region in maf format" << std::endl <<
          " -t   INT     number of threads (default: " << threads << ")" << std::endl <<
          " -v   FILE    output variant calling in vcf format (conflict with -IV)" << std::endl <<
          //          " -l   FILE    output local alignment for each anchor and inter-anchor region" << std::endl <<
          " -m   INT     minimum exon length to use (default: " << minExon << ", should be identical with the setting of gff2seq function)" << std::endl <<
          " -mi  DOUBLE  minimum full-length CDS anchor hit similarity to use (default:" << minimumSimilarity << ")" << std::endl <<
          " -mi2 DOUBLE  minimum novel anchor hit similarity to use (default:" << minimumSimilarity2 << ")" << std::endl <<
          " -ar  FILE    sam file generated by mapping conserved sequence to reference genome" << std::endl <<
          //          " -fa  INT     if fragment length is smaller than this value in inter-anchor region, use WFA to align (default: " << wfaSize << ")" << std::endl <<
          //          " -fa2 INT     if fragment length is smaller than this value in anchor region, use WFA to align (default: " << wfaSize2 << ")" << std::endl <<
          " -w   INT     sequence alignment window width (default: " << windownWidth << ")" << std::endl <<
          //"              If the fragment length is longer than -fa/-fa2, ProAli perform sequence alignment using a sliding window approach"  << std::endl <<
          " -fa3 INT     if the inter-anchor length is shorter than this value, stop trying to find new anchors (default: " << wfaSize3 << ")" << std::endl <<
          //          " -A   INT     matching score (default: " << matchingScore << ")" << std::endl <<
          " -B   INT     mismatching penalty (default: " << mismatchingPenalty << ")" << std::endl <<
          " -O1  INT     gap open penalty (default: " << openGapPenalty1 << ")" << std::endl <<
          " -E1  INT     gap extension penalty (default: " << extendGapPenalty1 << ")" << std::endl <<
          " -O2  INT     gap open penalty 2 (default: " << openGapPenalty2 << ")" << std::endl <<
          " -E2  INT     gap extension penalty 2 (default: " << extendGapPenalty2 << ")" << std::endl <<
          " -IV          whether to call inversions (default: false)" << std::endl <<
          " -IC  DOUBLE  penalty for having a non-linear match in inversion region (default: " << inversion_PENALTY << ")" << std::endl <<
          "              We use IC * alignment_similarity as the penalty in the inversion block" << std::endl <<
          " -I   DOUBLE  minimum score to keep an inversion (default: " << MIN_ALIGNMENT_SCORE << ")" << std::endl <<
          " -e   INT     maximum expected copy number of each gene on each chromosome (default: " << expectedCopies << ")" << std::endl << // this is used to duplicated anchors from the sam file
          "              This prevents using tandem duplicated genes to identify collinear block" << std::endl <<
          " -y   DOUBLE  minimal ratio of e+1 similarity to 1 similarity to drop an anchor (default: " << maximumSimilarity << ")" << std::endl <<
          //          " If you have enough memory on your computer and expect better alignment, please set large value for -w, -fa, -fa2 and -fa3 "  << std::endl <<
          //          " -wl  INT     min wavefront length (default: "<< min_wavefront_length << ")" << std::endl <<
          //          " -wd  INT     max distance threshold (default: "<< max_distance_threshold << ")" << std::endl <<
          //          "              -wl and -wd are parameters for WFA-Adaptive"  << std::endl <<
          " -ns          do not search for new anchors (default: false)" << std::endl <<
          " -x           use exon records instead of CDS from the GFF file (should be identical with the setting of gff2seq function)" << std::endl <<
          //          " Following parameters are for minimap2 library, useful to identify novel anchors when -ns is not set" << std::endl<<
          //          " -H	         Use homopolymer-compressed (HPC) minimizers. An HPC sequence is constructed by contracting homopolymer runs to a single base. An HPC minimizer is a minimizer on the HPC sequence." << std::endl<<
          //          " -k   INT	 Minimizer k-mer length (default: "<<k<<")" << std::endl<<
          //          " -mw  INT	 Minimizer window size(default: " << mw << "). A minimizer is the smallest k-mer in a window of w consecutive k-mers." << std::endl << std::endl <<
          //          " Following parameters are useful for local alignment when -l is set" << std::endl<<
          //          " -sw  INT     the windows size used to run the smith-waterman algorithm to get the alignment seed (default: "<<seed_window_size<<")" << std::endl <<
          //          " -c   INT     minimum seeds score to trigger a local alignment extension (default: " << mini_cns_score << ")" << std::endl <<
          //          " -st  INT     step size for sliding the smith-waterman seeds alignment window (default: " << step_size << ")" << std::endl <<
          //          " -ms  INT     minimum score to report a local sequence alignment (default: "<<scoreThreshold<<")" << std::endl <<
          //          " -x   INT     x-drop for local alignment (default: " << xDrop << ")" << std::endl <<
          //          " -u   INT     local alignment band width (default: " << w2 << ")" << std::endl <<
          std::endl;

    InputParser inputParser(argc, argv);
    if (inputParser.cmdOptionExists("-h") || inputParser.cmdOptionExists("--help")) {
        std::cerr << usage.str();
    } else if (inputParser.cmdOptionExists("-i") && inputParser.cmdOptionExists("-r") &&
               inputParser.cmdOptionExists("-a") && inputParser.cmdOptionExists("-s") && inputParser.cmdOptionExists("-as") &&
               (inputParser.cmdOptionExists("-n") || inputParser.cmdOptionExists("-f") || inputParser.cmdOptionExists("-v") || inputParser.cmdOptionExists("-o") || inputParser.cmdOptionExists("-l"))) {

        std::string refGffFilePath = inputParser.getCmdOption("-i");
        std::string referenceGenomeSequence = inputParser.getCmdOption("-r");
        std::string cdsSequenceFile = inputParser.getCmdOption("-as");
        std::string samFilePath = inputParser.getCmdOption("-a");
        std::string targetGenomeSequence = inputParser.getCmdOption("-s");
        std::string outPutMafFile;
        if (inputParser.cmdOptionExists("-o")) {
            outPutMafFile = inputParser.getCmdOption("-o");
        }

        std::string outPutFragedFile;
        if (inputParser.cmdOptionExists("-f")) {
            outPutFragedFile = inputParser.getCmdOption("-f");
        }
        if (inputParser.cmdOptionExists("-t")) {
            threads = std::stoi(inputParser.getCmdOption("-t"));
        }

        std::string outPutVcfFile;
        if (inputParser.cmdOptionExists("-v")) {
            outPutVcfFile = inputParser.getCmdOption("-v");
            if (inputParser.cmdOptionExists("-IV")) {
                std::cout << "please do not set -v and -IV together" << std::endl;
                return 1;
            }
        }
//
//        std::string outPutLocalalignmentFile;
//        if (inputParser.cmdOptionExists("-l") ){
//            outPutLocalalignmentFile = inputParser.getCmdOption("-l");
//        }

        if (inputParser.cmdOptionExists("-m")) {
            minExon = std::stoi(inputParser.getCmdOption("-m"));
        }
        if (inputParser.cmdOptionExists("-mi")) {
            minimumSimilarity = std::stod(inputParser.getCmdOption("-mi"));
        }
        if (inputParser.cmdOptionExists("-mi2")) {
            minimumSimilarity2 = std::stod(inputParser.getCmdOption("-mi2"));
        }

        std::string referenceSamFilePath;
        if (inputParser.cmdOptionExists("-ar")) {
            referenceSamFilePath = inputParser.getCmdOption("-ar");
        }

//        if( inputParser.cmdOptionExists("-fa") ){
//            wfaSize = std::stoi( inputParser.getCmdOption("-fa") );
//        }
//        if( inputParser.cmdOptionExists("-fa2")){
//            wfaSize2 = std::stoi(inputParser.getCmdOption("-fa2"));
//        }
        if (inputParser.cmdOptionExists("-fa3")) {
            wfaSize3 = std::stoi(inputParser.getCmdOption("-fa3"));
        }
//        if ( wfaSize2 < wfaSize ){
//            std::cout << "fa2 should be larger than fa" << std::endl;
//            return 1;
//        }

//
//        if( inputParser.cmdOptionExists("-A") ){
//            matchingScore = std::stoi( inputParser.getCmdOption("-A") );
//            if( matchingScore<0 ){
//                std::cout << "parameter of A should be a positive value" << std::endl;
//                return 1;
//            }
//        }
        if (inputParser.cmdOptionExists("-B")) {
            mismatchingPenalty = std::stoi(inputParser.getCmdOption("-B"));
            if (mismatchingPenalty >= 0) {
                std::cout << "parameter of B should be a negative value" << std::endl;
                return 1;
            }
        }
        if (inputParser.cmdOptionExists("-O1")) {
            openGapPenalty1 = std::stoi(inputParser.getCmdOption("-O1"));
            if (openGapPenalty1 >= 0) {
                std::cout << "parameter of O1 should be a negative value" << std::endl;
                return 1;
            }
        }
        if (inputParser.cmdOptionExists("-E1")) {
            extendGapPenalty1 = std::stoi(inputParser.getCmdOption("-E1"));
            if (extendGapPenalty1 >= 0) {
                std::cout << "parameter of E1 should be a negative value" << std::endl;
                return 1;
            }
        }

        if (inputParser.cmdOptionExists("-O2")) {
            openGapPenalty2 = std::stoi(inputParser.getCmdOption("-O2"));
            if (openGapPenalty2 >= 0) {
                std::cout << "parameter of O1 should be a negative value" << std::endl;
                return 1;
            }
        }
        if (inputParser.cmdOptionExists("-E2")) {
            extendGapPenalty2 = std::stoi(inputParser.getCmdOption("-E2"));
            if (extendGapPenalty2 > 0) {
                std::cout << "parameter of E1 should be a negative value" << std::endl;
                return 1;
            }
        }
        if (inputParser.cmdOptionExists("-IV")) {
            considerInversion = true;
        }
        if (inputParser.cmdOptionExists("-IC")) {
            inversion_PENALTY = std::stod(inputParser.getCmdOption("-IC"));
            if (inversion_PENALTY >= 0) {
                std::cout << "parameter of IC should be a negative value" << std::endl;
                return 1;
            }
        }
        if (inputParser.cmdOptionExists("-I")) {
            MIN_ALIGNMENT_SCORE = std::stod(inputParser.getCmdOption("-I"));
        }

        if (MIN_ALIGNMENT_SCORE < 1) {
            std::cout << "minimum score to keep an inversion is not larger than 1, maybe output weired inversions. please change it" << std::endl;
            return 1;
        }
        if (inputParser.cmdOptionExists("-e")) {
            expectedCopies = std::stoi(inputParser.getCmdOption("-e"));
        }

        if (inputParser.cmdOptionExists("-y")) {
            maximumSimilarity = std::stod(inputParser.getCmdOption("-y"));
        }
        if (inputParser.cmdOptionExists("-w")) {
            windownWidth = std::stoi(inputParser.getCmdOption("-w"));
        }
        if (inputParser.cmdOptionExists("-wl")) {
            min_wavefront_length = std::stoi(inputParser.getCmdOption("-wl"));
        }

        if (inputParser.cmdOptionExists("-wd")) {
            max_distance_threshold = std::stoi(inputParser.getCmdOption("-wd"));
        }
        if (inputParser.cmdOptionExists("-ns")) {
            searchForNewAnchors = false;
        }
        if (inputParser.cmdOptionExists("-H")) {
            H = true;
        }
        if (inputParser.cmdOptionExists("-k")) {
            k = std::stoi(inputParser.getCmdOption("-k"));
        }

        if (inputParser.cmdOptionExists("-mw")) {
            mw = std::stoi(inputParser.getCmdOption("-mw"));
        }
        if (inputParser.cmdOptionExists("-sw")) {
            seed_window_size = std::stoi(inputParser.getCmdOption("-sw"));
        }
        if (inputParser.cmdOptionExists("-c")) {
            mini_cns_score = std::stoi(inputParser.getCmdOption("-c"));
        }
        if (inputParser.cmdOptionExists("-st")) {
            step_size = std::stoi(inputParser.getCmdOption("-st"));
        }
        if (inputParser.cmdOptionExists("-ms")) {
            scoreThreshold = std::stoi(inputParser.getCmdOption("-ms"));
        }
//
//        if( inputParser.cmdOptionExists("-x") ){
//            xDrop = std::stoi( inputParser.getCmdOption("-x") );
//        }
        if (inputParser.cmdOptionExists("-u")) {
            w2 = std::stoi(inputParser.getCmdOption("-u"));
        }
        if (inputParser.cmdOptionExists("-x")) {
            exonModel = true;
        }

        std::map<std::string, std::string> referenceGenome;
        readFastaFile(referenceGenomeSequence, referenceGenome);

        std::map<std::string, std::string> queryGenome;
        readFastaFile(targetGenomeSequence, queryGenome);

        std::map<std::string, std::vector<AlignmentMatch>> alignmentMatchsMap;
        setupAnchorsWithSpliceAlignmentResult(refGffFilePath, cdsSequenceFile, samFilePath, alignmentMatchsMap,
                                              inversion_PENALTY, MIN_ALIGNMENT_SCORE, considerInversion, minExon, windownWidth, minimumSimilarity, minimumSimilarity2, parameters, referenceGenome,
                                              queryGenome, expectedCopies, maximumSimilarity, referenceSamFilePath, wfaSize3, searchForNewAnchors, exonModel
                /*, matchingScore, mismatchingPenalty, openGapPenalty1, extendGapPenalty1, k, mw, H*/);


        //        std::cout << "control line 363" << std::endl;

        for (std::map<std::string, std::vector<AlignmentMatch>>::iterator it = alignmentMatchsMap.begin(); it != alignmentMatchsMap.end(); ++it) {
            //         std::cout << "control line 365\t" << it->first << "\t" << it->first.size() << std::endl;
            myAlignmentMatchSort(it->second, inversion_PENALTY, MIN_ALIGNMENT_SCORE, false, false);
            //          std::cout << "control line 367" << std::endl;
        }
        //    std::cout << "control line 369" << std::endl;
        if (inputParser.cmdOptionExists("-n")) {
            std::string wholeCommand = argv[0];
            for (int i = 1; i < argc; ++i) {
                wholeCommand = wholeCommand + " " + argv[i];
            }
//            std::cout << "control line 375" << std::endl;
            std::ofstream ofile;
            ofile.open(inputParser.getCmdOption("-n"));
            ofile << "#" << PROGRAMNAME << " " << wholeCommand << std::endl;
            int blockIndex = 0;
            ofile << "refChr" << "\t"
                  << "referenceStart" << "\t"
                  << "referenceEnd" << "\t"
                  << "queryChr" << "\t"
                  << "queryStart" << "\t"
                  << "queryEnd" << "\t"
                  << "strand" << "\t"
                  << "gene" << "\t"
                  << "blockIndex" << "\tscore" << std::endl;

            for (std::map<std::string, std::vector<AlignmentMatch>>::iterator it = alignmentMatchsMap.begin(); it != alignmentMatchsMap.end(); ++it) {
                ofile << "#block begin" << std::endl;
                blockIndex++;
                bool hasInversion = false;
                for (int rangeIndex = 0; rangeIndex < it->second.size(); ++rangeIndex) {
                    if (rangeIndex > 0) {
                        if (it->second[rangeIndex].getStrand() == POSITIVE && it->second[rangeIndex - 1].getStrand() == POSITIVE) {
                            ofile << it->second[rangeIndex].getRefChr() << "\t"
                                  << it->second[rangeIndex - 1].getRefEndPos() + 1 << "\t"
                                  << it->second[rangeIndex].getRefStartPos() - 1 << "\t"
                                  << it->second[rangeIndex].getQueryChr() << "\t"
                                  << it->second[rangeIndex - 1].getQueryEndPos() + 1 << "\t"
                                  << it->second[rangeIndex].getQueryStartPos() - 1 << "\t"
                                  << "+" << "\t"
                                  << "interanchor" << "\t" <<
                                  blockIndex << "\tNA" << std::endl;
                        } else if (it->second[rangeIndex].getStrand() == NEGATIVE && it->second[rangeIndex - 1].getStrand() == NEGATIVE
                                   && it->second[rangeIndex - 1].getRefEndPos() < it->second[rangeIndex].getRefStartPos()
                                   && it->second[rangeIndex - 1].getQueryStartPos() > it->second[rangeIndex].getQueryEndPos()
//                        && it->second[rangeIndex-1].getRefEndPos() != it->second[rangeIndex].getRefStartPos()-1 && it->second[rangeIndex-1].getQueryStartPos() -1  != it->second[rangeIndex].getQueryEndPos()
//                                && it->second[rangeIndex-1].getRefStartPos() > it->second[rangeIndex].getRefEndPos()
//                                && it->second[rangeIndex-1].getQueryEndPos() < it->second[rangeIndex].getQueryStartPos()
                                ) {
                            ofile << it->second[rangeIndex].getRefChr() << "\t"
                                  << it->second[rangeIndex - 1].getRefEndPos() + 1 << "\t"
                                  << it->second[rangeIndex].getRefStartPos() - 1 << "\t"
                                  << it->second[rangeIndex].getQueryChr() << "\t"
                                  << it->second[rangeIndex].getQueryEndPos() + 1 << "\t"
                                  << it->second[rangeIndex - 1].getQueryStartPos() - 1 << "\t"
                                  << "-" << "\t"
                                  << "interanchor" << "\t" <<
                                  blockIndex << "\tNA" << std::endl;
                        }
                    }
                    std::string thisStrand = "+";
                    if (it->second[rangeIndex].getStrand() == NEGATIVE) {
                        thisStrand = "-";
                        hasInversion = true;
                    }

                    ofile << it->second[rangeIndex].getRefChr() << "\t"
                          << it->second[rangeIndex].getRefStartPos() << "\t"
                          << it->second[rangeIndex].getRefEndPos() << "\t"
                          << it->second[rangeIndex].getQueryChr() << "\t"
                          << it->second[rangeIndex].getQueryStartPos() << "\t"
                          << it->second[rangeIndex].getQueryEndPos() << "\t"
                          << thisStrand << "\t"
                          << it->second[rangeIndex].getReferenceGeneName() << "\t";

                    if (it->second[rangeIndex].getReferenceGeneName().find("localAlignment") == std::string::npos) {
                        ofile << blockIndex << "\t" << it->second[rangeIndex].getScore() << std::endl;
                    } else {
                        ofile << blockIndex << "\t" << "NA" << std::endl;
                    }
//                          blockIndex <<"\t" << it->second[rangeIndex].getScore() << std::endl;
                }

                int rangeIndex = it->second.size() - 1;
                if (!hasInversion) {
                    ofile << it->second[rangeIndex].getRefChr() << "\t"
                          << it->second[rangeIndex].getRefEndPos() + 1 << "\t"
                          << referenceGenome[it->second[rangeIndex].getRefChr()].size() << "\t"
                          << it->second[rangeIndex].getQueryChr() << "\t"
                          << it->second[rangeIndex].getQueryEndPos() + 1 << "\t"
                          << queryGenome[it->second[rangeIndex].getQueryChr()].size() << "\t"
                          << "+" << "\t"
                          << "interanchor" << "\t" <<
                          blockIndex << "\tNA" << std::endl;
                }
                ofile << "#block end" << std::endl;
            }
            ofile.close();
        }

        if (inputParser.cmdOptionExists("-f") || inputParser.cmdOptionExists("-v")
            || inputParser.cmdOptionExists("-o") || inputParser.cmdOptionExists("-l")) {

            genomeAlignmentAndVariantCalling(alignmentMatchsMap, referenceGenomeSequence, targetGenomeSequence,
                                             windownWidth, wfaSize, wfaSize2,
                                             outPutMafFile, outPutVcfFile, outPutFragedFile, /*outPutLocalalignmentFile,*/
                                             matchingScore, mismatchingPenalty, openGapPenalty1, extendGapPenalty1,
                                             openGapPenalty2, extendGapPenalty2, min_wavefront_length, max_distance_threshold,
                                             seed_window_size, mini_cns_score, step_size, matrix_boundary_distance,
                                             scoreThreshold, w2, xDrop, threads, parameters);
            std::cout << "AnchorWave done!" << std::endl;
        }
        return 0;
    } else {
        std::cerr << usage.str();
    }
    return 0;
}

int proportationalAlignment(int argc, char **argv, std::map<std::string, std::string> &parameters) {
    bool useAlignmentScore = false;

    int32_t matchingScore = 0;
    int32_t mismatchingPenalty = -4;
    int32_t openGapPenalty1 = -4;
    int32_t extendGapPenalty1 = -2;

    int32_t openGapPenalty2 = -80;
    int32_t extendGapPenalty2 = -1;

    //double MIN_ALIGNMENT_SCORE = 6000;

    double MIN_ALIGNMENT_SCORE = 2;

    int minExon = 20;
    double minimumSimilarity = 0;
    double minimumSimilarity2 = 0;

    int32_t wfaSize = 15000;
    int32_t wfaSize2 = 50000;
    int32_t wfaSize3 = 200000; // if the inter-anchor length is shorter than this value, stop trying to find new anchors
    int64_t windownWidth = 38000;
    int expectedCopies = 1;
    double maximumSimilarity = 0.6;
    int32_t min_wavefront_length = 20;
    int32_t max_distance_threshold = 100;

    int32_t seed_window_size = 38;
    int32_t mini_cns_score = 30;
    int32_t step_size = 8;
    int32_t matrix_boundary_distance = 0;
    bool searchForNewAnchors = true;

    int k = 12;
    int mw = 1;
    bool H = false;

    int32_t scoreThreshold = 54;
    int32_t w2 = 10;  //this is the band width for band sequence alignments
    int32_t xDrop = 20;

    double calculateIndelDistance = 3;

    double GAP_OPEN_PENALTY = -0.03;
    double INDEL_SCORE = -0.01;

    int MAX_DIST_BETWEEN_MATCHES = 25;  // between maize and sorghum set it as 25*3000
    int refMaximumTimes = 1;
    int queryMaximumTimes = 2;
    bool outPutAlignmentForEachInterval = false;
//    bool localAlignment = false;

    int threads = 1;
    bool exonModel = false;
    std::stringstream usage;
    usage << "Usage: " << PROGRAMNAME
          << " proali -i refGffFile -r refGenome -a cds.sam -as cds.fa -ar ref.sam -s targetGenome -n outputAnchorFile -o output.maf -f output.fragmentation.maf -R 1 -Q 1" << std::endl <<
          "Options" << std::endl <<
          " -h           produce help message" << std::endl <<
          " -i   FILE    reference GFF/GTF file" << std::endl <<
          " -r   FILE    reference genome sequence" << std::endl <<
          " -as  FILE    anchor sequence file. (output from the gff2seq command)" << std::endl <<
          " -a   FILE    sam file by mapping conserved sequence to query genome" << std::endl <<
          " -s   FILE    target genome sequence" << std::endl <<
          " -n   FILE    output anchors file" << std::endl <<
          " -o   FILE    output file in maf format" << std::endl <<
          " -f   FILE    output sequence alignment for each anchor/inter-anchor region in maf format" << std::endl <<
          " -t   INT     number of threads (default: " << threads << ")" << std::endl <<
          //          " -l   FILE    output local alignment for each anchor and inter-anchor region" << std::endl <<
          //          " -fa  INT     if fragment length is smaller than this value in inter-anchor region, use WFA to align (default: " << wfaSize << ")" << std::endl <<
          //          " -fa2 INT     if fragment length is smaller than this value in anchor region, use WFA to align (default: " << wfaSize2 << ")" << std::endl <<
          " -fa3 INT     if the inter-anchor length is shorter than this value, stop trying to find new anchors (default: " << wfaSize3 << ")" << std::endl <<
          " -w   INT     sequence alignment window width (default: " << windownWidth << ")" << std::endl <<
          //          "              If the fragment length is longer than -fa/-fa2, ProAli perform sequence alignment using a sliding window approach"  << std::endl <<
          //          "              If you have enough memory on your computer and expect better alignment, please set large value for -w, -fa, -fa2 and -fa3 "  << std::endl  <<
          //          " -wl  INT     min wavefront length (default: "<< min_wavefront_length << ")" << std::endl <<
          //          " -wd  INT     max distance threshold (default: "<< max_distance_threshold << ")" << std::endl <<
          //          "              -wl and -wd are parameters for WFA-Adaptive"  << std::endl <<
          " -R   INT     reference genome maximum alignment coverage " << std::endl <<
          " -Q   INT     query genome maximum alignment coverage " << std::endl <<
          //          " -A   INT     matching score (default: " << matchingScore << ")" << std::endl <<
          " -B   INT     mismatching penalty (default: " << mismatchingPenalty << ")" << std::endl <<
          " -O1  INT     open gap penalty (default: " << openGapPenalty1 << ")" << std::endl <<
          " -E1  INT     extend gap penalty (default: " << extendGapPenalty1 << ")" << std::endl <<
          " -O2  INT     open gap penalty 2 (default: " << openGapPenalty2 << ")" << std::endl <<
          " -E2  INT     extend gap penalty 2 (default: " << extendGapPenalty2 << ")" << std::endl <<
          " -m   INT     minimum exon length to use (default: " << minExon << ", should be identical with the setting of gff2seq function)" << std::endl <<
          " -mi  DOUBLE  minimum full-length CDS anchor hit similarity to use (default:" << minimumSimilarity << ")" << std::endl <<
          " -mi2 DOUBLE  minimum novel anchor hit similarity to use (default:" << minimumSimilarity2 << ")" << std::endl <<
          " -e   INT     maximum expected copy number of each gene on each chromosome (default: " << expectedCopies << ")" << std::endl << // this is used to duplicated anchors from the sam file
          "              This prevents using tandem duplicated genes to identify collinear block" << std::endl <<
          " -y   DOUBLE  minimal ratio of e+1 similarity to 1 similarity to drop an anchor (default: " << maximumSimilarity << ")" << std::endl <<
          " -ar  FILE    sam file by mapping conserved sequence to reference genome" << std::endl <<
          "              this is used to improve the accuracy of anchors mapping" << std::endl <<
          " Following parameters are to identify collinear blocks" << std::endl <<
          " -d   DOUBLE  calculate IndelDistance (default: " << calculateIndelDistance << ")" << std::endl <<
          " -O   DOUBLE  chain open gap penalty (default: " << GAP_OPEN_PENALTY << ")" << std::endl <<
          " -E   DOUBLE  chain extend gap penalty (default: " << INDEL_SCORE << ")" << std::endl <<
          " -I   DOUBLE  minimum chain score (default: " << MIN_ALIGNMENT_SCORE << ")" << std::endl <<
          " -D   INT     maximum gap size for chain (default: " << MAX_DIST_BETWEEN_MATCHES << ")" << std::endl <<
          " -ns          do not search for new anchors (default: false)" << std::endl <<
          " -x           use exon records instead of CDS from the GFF file (should be identical with the setting of gff2seq function)" << std::endl <<
          //          " -ua          use alignment score to identify collinear blocks (default: false)" << std::endl <<
          //          "              by default, we use proportion of sequence similarity as score to identify collinear block." << std::endl <<
          //          "              if this parameter is set true, we use the sequence alignment score instead.  " << std::endl << std::endl<<
          //          " Following parameters are for minimap2 library, useful to identify novel anchors when -ns is not set" << std::endl<<
          //          " -H	         Use homopolymer-compressed (HPC) minimizers. An HPC sequence is constructed by contracting homopolymer runs to a single base. An HPC minimizer is a minimizer on the HPC sequence." << std::endl<<
          //          " -k   INT	 Minimizer k-mer length (default: "<<k<<")" << std::endl<<
          //          " -mw  INT	 Minimizer window size(default: " << mw << "). A minimizer is the smallest k-mer in a window of w consecutive k-mers." << std::endl<< std::endl<<
          //          " Following parameters are useful for local alignment when -l is set" << std::endl<<
          //          " -sw  INT     the windows size used to run the smith-waterman algorithm to get the alignment seed (default: "<<seed_window_size<<")" << std::endl <<
          //          " -c   INT     minimum seeds score to trigger a local alignment extension (default: " << mini_cns_score << ")" << std::endl <<
          //          " -st  INT     step size for sliding the smith-waterman seeds alignment window (default: " << step_size << ")" << std::endl <<
          //          " -ms  INT     minimum score to report a local sequence alignment (default: "<<scoreThreshold<<")" << std::endl <<
          //          " -x   INT     x-drop for local alignment (default: " << xDrop << ")" << std::endl <<
          //          " -u   INT     local alignment band width (default: " << w2 << ")" << std::endl <<
          std::endl;

    InputParser inputParser(argc, argv);
    if (inputParser.cmdOptionExists("-h") || inputParser.cmdOptionExists("--help")) {
        std::cerr << usage.str();
    } else if (inputParser.cmdOptionExists("-i") && inputParser.cmdOptionExists("-r") &&
               inputParser.cmdOptionExists("-a") && inputParser.cmdOptionExists("-s") &&
               inputParser.cmdOptionExists("-as") && (inputParser.cmdOptionExists("-n")
                                                      || inputParser.cmdOptionExists("-f") || inputParser.cmdOptionExists("-v")
                                                      || inputParser.cmdOptionExists("-o")  /*|| inputParser.cmdOptionExists("-l")  */)) {

        std::string refGffFilePath = inputParser.getCmdOption("-i");
        std::string referenceGenomeSequence = inputParser.getCmdOption("-r");
        std::string cdsSequenceFile = inputParser.getCmdOption("-as");
        std::string samFilePath = inputParser.getCmdOption("-a");
        std::string targetGenomeSequence = inputParser.getCmdOption("-s");

        std::string outPutMafFile;
        if (inputParser.cmdOptionExists("-o")) {
            outPutMafFile = inputParser.getCmdOption("-o");
        }

        std::string outPutFragedFile;
        if (inputParser.cmdOptionExists("-f")) {
            outPutFragedFile = inputParser.getCmdOption("-f");
        }
        if (inputParser.cmdOptionExists("-t")) {
            threads = std::stoi(inputParser.getCmdOption("-t"));
        }

//
//        std::string outPutLocalalignmentFile;
//        if (inputParser.cmdOptionExists("-l") ){
//            outPutLocalalignmentFile = inputParser.getCmdOption("-l");
//        }

//        if( inputParser.cmdOptionExists("-fa")){
//            wfaSize = std::stoi(inputParser.getCmdOption("-fa"));
//        }
//        if( inputParser.cmdOptionExists("-fa2")){
//            wfaSize2 = std::stoi(inputParser.getCmdOption("-fa2"));
//        }
        if (inputParser.cmdOptionExists("-fa3")) {
            wfaSize3 = std::stoi(inputParser.getCmdOption("-fa3"));
        }
//        if ( wfaSize2 < wfaSize ){
//            std::cout << "fa2 should be larger than fa" << std::endl;
//            return 1;
//        }
        if (inputParser.cmdOptionExists("-w")) {
            windownWidth = std::stoi(inputParser.getCmdOption("-w"));
        }

        if (inputParser.cmdOptionExists("-wl")) {
            min_wavefront_length = std::stoi(inputParser.getCmdOption("-wl"));
        }

        if (inputParser.cmdOptionExists("-wd")) {
            max_distance_threshold = std::stoi(inputParser.getCmdOption("-wd"));
        }

        if (inputParser.cmdOptionExists("-R")) {
            refMaximumTimes = std::stoi(inputParser.getCmdOption("-R"));
        } else {
            std::cerr << "parameter -R is required" << std::endl;
            std::cerr << usage.str();
            return 1;
        }

        if (inputParser.cmdOptionExists("-Q")) {
            queryMaximumTimes = std::stoi(inputParser.getCmdOption("-Q"));
        } else {
            std::cerr << "parameter -Q is required" << std::endl;
            std::cerr << usage.str();
            return 1;
        }
//
//        if( inputParser.cmdOptionExists("-A") ){
//            matchingScore = std::stoi( inputParser.getCmdOption("-A") );
//            if( matchingScore<0 ){
//                std::cout << "parameter of A should be a positive value" << std::endl;
//                return 1;
//            }
//        }
        if (inputParser.cmdOptionExists("-B")) {
            mismatchingPenalty = std::stoi(inputParser.getCmdOption("-B"));
            if (mismatchingPenalty >= 0) {
                std::cout << "parameter of B should be a negative value" << std::endl;
                return 1;
            }
        }
        if (inputParser.cmdOptionExists("-O1")) {
            openGapPenalty1 = std::stoi(inputParser.getCmdOption("-O1"));
            if (openGapPenalty1 >= 0) {
                std::cout << "parameter of O1 should be a negative value" << std::endl;
                return 1;
            }
        }
        if (inputParser.cmdOptionExists("-E1")) {
            extendGapPenalty1 = std::stoi(inputParser.getCmdOption("-E1"));
            if (extendGapPenalty1 >= 0) {
                std::cout << "parameter of E1 should be a negative value" << std::endl;
                return 1;
            }
        }

        if (inputParser.cmdOptionExists("-O2")) {
            openGapPenalty2 = std::stoi(inputParser.getCmdOption("-O2"));
            if (openGapPenalty2 >= 0) {
                std::cout << "parameter of O1 should be a negative value" << std::endl;
                return 1;
            }
        }
        if (inputParser.cmdOptionExists("-E2")) {
            extendGapPenalty2 = std::stoi(inputParser.getCmdOption("-E2"));
            if (extendGapPenalty2 > 0) {
                std::cout << "parameter of E1 should be a negative value" << std::endl;
                return 1;
            }
        }

        if (inputParser.cmdOptionExists("-m")) {
            minExon = std::stoi(inputParser.getCmdOption("-m"));
        }
        if (inputParser.cmdOptionExists("-mi")) {
            minimumSimilarity = std::stod(inputParser.getCmdOption("-mi"));
        }
        if (inputParser.cmdOptionExists("-mi2")) {
            minimumSimilarity2 = std::stod(inputParser.getCmdOption("-mi2"));
        }


        if (inputParser.cmdOptionExists("-e")) {
            expectedCopies = std::stoi(inputParser.getCmdOption("-e"));
        }

        if (inputParser.cmdOptionExists("-y")) {
            maximumSimilarity = std::stod(inputParser.getCmdOption("-y"));
        }
//
//        if( localAlignment && outPutAlignmentForEachInterval ){
//            std::cout << "please do not perform local alignment and global alignment for each interval at the same time" << std::endl;
//            return 1;
//        }

        std::string referenceSamFilePath;
        if (inputParser.cmdOptionExists("-ar")) {
            referenceSamFilePath = inputParser.getCmdOption("-ar");
        }


        if (inputParser.cmdOptionExists("-d")) {
            calculateIndelDistance = std::stod(inputParser.getCmdOption("-d"));
        }
        if (inputParser.cmdOptionExists("-O")) {
            GAP_OPEN_PENALTY = std::stod(inputParser.getCmdOption("-O"));
        }
        if (inputParser.cmdOptionExists("-E")) {
            INDEL_SCORE = std::stod(inputParser.getCmdOption("-E"));
        }
        if (inputParser.cmdOptionExists("-I")) {
            MIN_ALIGNMENT_SCORE = std::stod(inputParser.getCmdOption("-I"));
        }
        if (inputParser.cmdOptionExists("-D")) {
            MAX_DIST_BETWEEN_MATCHES = std::stoi(inputParser.getCmdOption("-D"));
        }

        if (inputParser.cmdOptionExists("-ns")) {
            searchForNewAnchors = false;
        }

        if (inputParser.cmdOptionExists("-ua")) {
            GAP_OPEN_PENALTY = -4;
            INDEL_SCORE = -2;
            MAX_DIST_BETWEEN_MATCHES = 25;
            useAlignmentScore = true;
        }

        if (inputParser.cmdOptionExists("-H")) {
            H = true;
        }


        if (inputParser.cmdOptionExists("-f")) {
            outPutAlignmentForEachInterval = true;
        }
//        if( inputParser.cmdOptionExists("-l")){
//            localAlignment = true;
//        }

        if (inputParser.cmdOptionExists("-k")) {
            k = std::stoi(inputParser.getCmdOption("-k"));
        }

        if (inputParser.cmdOptionExists("-mw")) {
            mw = std::stoi(inputParser.getCmdOption("-mw"));
        }

        if (inputParser.cmdOptionExists("-sw")) {
            seed_window_size = std::stoi(inputParser.getCmdOption("-sw"));
        }
        if (inputParser.cmdOptionExists("-c")) {
            mini_cns_score = std::stoi(inputParser.getCmdOption("-c"));
        }
        if (inputParser.cmdOptionExists("-st")) {
            step_size = std::stoi(inputParser.getCmdOption("-st"));
        }
        if (inputParser.cmdOptionExists("-ms")) {
            scoreThreshold = std::stoi(inputParser.getCmdOption("-ms"));
        }
//        if( inputParser.cmdOptionExists("-x") ){
//            xDrop = std::stoi( inputParser.getCmdOption("-x") );
//        }
        if (inputParser.cmdOptionExists("-u")) {
            w2 = std::stoi(inputParser.getCmdOption("-u"));
        }

        std::vector<std::vector<AlignmentMatch>> alignmentMatchsMap;
        std::map<std::string, std::string> referenceGenome;
        readFastaFile(referenceGenomeSequence, referenceGenome);
        std::map<std::string, std::string> queryGenome;
        readFastaFile(targetGenomeSequence, queryGenome);

        if (inputParser.cmdOptionExists("-x")) {
            exonModel = true;
        }

        setupAnchorsWithSpliceAlignmentResultQuota(refGffFilePath, samFilePath, cdsSequenceFile, alignmentMatchsMap, INDEL_SCORE, GAP_OPEN_PENALTY, MIN_ALIGNMENT_SCORE,
                                                   MAX_DIST_BETWEEN_MATCHES, refMaximumTimes, queryMaximumTimes,
                                                   calculateIndelDistance, minExon, windownWidth, minimumSimilarity, minimumSimilarity2, parameters, referenceGenome, queryGenome,
                                                   expectedCopies, wfaSize3, maximumSimilarity, referenceSamFilePath,
                /*matchingScore, mismatchingPenalty, openGapPenalty1, extendGapPenalty1, k, mw, H,*/ searchForNewAnchors, exonModel);

        if (inputParser.cmdOptionExists("-n")) {
            std::string wholeCommand = argv[0];
            for (int i = 1; i < argc; ++i) {
                wholeCommand = wholeCommand + " " + argv[i];
            }

            std::ofstream ofile;
            ofile.open(inputParser.getCmdOption("-n"));
            ofile << "#" << PROGRAMNAME << " " << wholeCommand << std::endl;
            ofile << "refChr" << "\t"
                  << "referenceStart" << "\t"
                  << "referenceEnd" << "\t"
                  << "queryChr" << "\t"
                  << "queryStart" << "\t"
                  << "queryEnd" << "\t"
                  << "strand" << "\t"
                  << "gene" << "\t"
                  << "blockIndex" << "\t"
                  << "score" << std::endl;

            size_t totalAnchors = 0;
            int blockIndex = 0;
            for (std::vector<AlignmentMatch> alignmentMatchs: alignmentMatchsMap) {
                ofile << "#block begin" << std::endl;
                blockIndex++;
                for (int rangeIndex = 0; rangeIndex < alignmentMatchs.size(); ++rangeIndex) {

                    std::string thisStrand = "+";
                    if (alignmentMatchs[rangeIndex].getStrand() == NEGATIVE) {
                        thisStrand = "-";
                    }

                    if (rangeIndex > 0) {
                        if (alignmentMatchs[rangeIndex].getStrand() == POSITIVE &&
                            alignmentMatchs[rangeIndex - 1].getStrand() == POSITIVE) {
                            ofile << alignmentMatchs[rangeIndex].getRefChr() << "\t"
                                  << alignmentMatchs[rangeIndex - 1].getRefEndPos() + 1 << "\t"
                                  << alignmentMatchs[rangeIndex].getRefStartPos() - 1 << "\t"
                                  << alignmentMatchs[rangeIndex].getQueryChr() << "\t"
                                  << alignmentMatchs[rangeIndex - 1].getQueryEndPos() + 1 << "\t"
                                  << alignmentMatchs[rangeIndex].getQueryStartPos() - 1 << "\t"
                                  << "+" << "\t" <<
                                  "interanchor" << "\t" <<
                                  blockIndex << "\tNA" << std::endl;
                        } else if (alignmentMatchs[rangeIndex].getStrand() == NEGATIVE &&
                                   alignmentMatchs[rangeIndex - 1].getStrand() == NEGATIVE) {
                            ofile << alignmentMatchs[rangeIndex].getRefChr() << "\t"
                                  << alignmentMatchs[rangeIndex - 1].getRefEndPos() + 1 << "\t"
                                  << alignmentMatchs[rangeIndex].getRefStartPos() - 1 << "\t"
                                  << alignmentMatchs[rangeIndex].getQueryChr() << "\t"
                                  << alignmentMatchs[rangeIndex].getQueryEndPos() + 1 << "\t"
                                  << alignmentMatchs[rangeIndex - 1].getQueryStartPos() - 1 << "\t"
                                  << "-" << "\t" <<
                                  "interanchor" << "\t" <<
                                  blockIndex << "\tNA" << std::endl;
                        }
                    }

                    ofile << alignmentMatchs[rangeIndex].getRefChr() << "\t"
                          << alignmentMatchs[rangeIndex].getRefStartPos() << "\t"
                          << alignmentMatchs[rangeIndex].getRefEndPos() << "\t"
                          << alignmentMatchs[rangeIndex].getQueryChr() << "\t"
                          << alignmentMatchs[rangeIndex].getQueryStartPos() << "\t"
                          << alignmentMatchs[rangeIndex].getQueryEndPos() << "\t"
                          << thisStrand << "\t"
                          << alignmentMatchs[rangeIndex].getReferenceGeneName() << "\t";

                    if (alignmentMatchs[rangeIndex].getReferenceGeneName().find("localAlignment") == std::string::npos) {
                        totalAnchors++;
                        ofile << blockIndex << "\t" << alignmentMatchs[rangeIndex].getScore() << std::endl;
                    } else {
                        ofile << blockIndex << "\t" << "NA" << std::endl;
                    }
                }
                ofile << "#block end" << std::endl;
            }

            ofile.close();
            std::cout << "totalAnchors:" << totalAnchors << std::endl;
        }

        if (inputParser.cmdOptionExists("-f") || inputParser.cmdOptionExists("-v") || inputParser.cmdOptionExists("-o") || inputParser.cmdOptionExists("-l")) {
            genomeAlignment(alignmentMatchsMap, referenceGenomeSequence, targetGenomeSequence, windownWidth, wfaSize, wfaSize2,
                            outPutMafFile, outPutFragedFile, /*outPutLocalalignmentFile,*/ matchingScore, mismatchingPenalty, openGapPenalty1, extendGapPenalty1,
                            openGapPenalty2, extendGapPenalty2, seed_window_size, mini_cns_score, step_size, matrix_boundary_distance,
                            scoreThreshold, w2, xDrop, min_wavefront_length, max_distance_threshold, threads, parameters);
            std::cout << "AnchorWave done!" << std::endl;
        }

        return 0;
    }
    else {
        std::cerr << usage.str();
    }

    return 0;
}

int tripleAncestral(int argc, char **argv, std::map<std::string, std::string> &parameters) {

    int32_t matchingScore = 0;
    int32_t mismatchingPenalty = -4;
    int32_t openGapPenalty1 = -4;
    int32_t extendGapPenalty1 = -2;

    int32_t openGapPenalty2 = -80;
    int32_t extendGapPenalty2 = -1;

    int64_t windownWidth = 30000;

    int32_t wfaSize = 15000;

    int32_t min_wavefront_length = 20;
    int32_t max_distance_threshold = 100;

    int miniInsertionSize = 15;
    int maxDistance = 25;

    std::stringstream usage;
    usage << "Usage: " << PROGRAMNAME
          << " proali triAnc -r1 ref1Genome -r2 ref2Genome -r1r2 r1r2.maf -r1q r1q.maf -r2q r2q.maf -o ancestor.fa " << std::endl <<
          "Options" << std::endl <<
          " -h           produce help message" << std::endl <<
          " -r1   FILE   reference 1 genome sequence" << std::endl <<
          " -r2   FILE   reference 2 genome sequence" << std::endl <<
          " -r1r2 FILE   reference 1 to reference 2 alignment (output from the genoAli or proali command)" << std::endl <<
          " -r1q  FILE   reference 1 to query alignment (output from the genoAli or proali command)" << std::endl <<
          " -r2q  FILE   reference 2 to query alignment (output from the genoAli or proali command)" << std::endl <<
          " -o    FILE   output file in FASTA format" << std::endl <<
          " Following parameters are for realign insertions" << std::endl <<
          " -n   INT     minimum insertion size for realignment (default: " << miniInsertionSize << ")" << std::endl <<
          " -m   INT     maximum distance for neighbour insertions to merge together for realignment (default: " << maxDistance << ")" << std::endl <<
          " -w   INT     sequence alignment window width (default: " << windownWidth << ")" << std::endl <<
          " -B   INT     mismatching penalty (default: " << mismatchingPenalty << ")" << std::endl <<
          " -O1  INT     open gap penalty (default: " << openGapPenalty1 << ")" << std::endl <<
          " -E1  INT     extend gap penalty (default: " << extendGapPenalty1 << ")" << std::endl <<
          " -O2  INT     open gap penalty 2 (default: " << openGapPenalty2 << ")" << std::endl <<
          " -E2  INT     extend gap penalty 2 (default: " << extendGapPenalty2 << ")" << std::endl << std::endl;

    InputParser inputParser(argc, argv);
    if (inputParser.cmdOptionExists("-h") || inputParser.cmdOptionExists("--help")) {
        std::cerr << usage.str();
    }
    else if (inputParser.cmdOptionExists("-r1") && inputParser.cmdOptionExists("-r2") &&
               inputParser.cmdOptionExists("-r1r2") && inputParser.cmdOptionExists("-r1q") &&
               inputParser.cmdOptionExists("-r2q")) {

        std::string reference1GenomeSequence = inputParser.getCmdOption("-r1");
        std::string reference2GenomeSequence = inputParser.getCmdOption("-r2");
        std::string ref1Ref2Maf = inputParser.getCmdOption("-r1r2");
        std::string ref1QueryMaf = inputParser.getCmdOption("-r1q");
        std::string ref2QueryMaf = inputParser.getCmdOption("-r2q");
        std::string outPutFile = inputParser.getCmdOption("-o");
        if (inputParser.cmdOptionExists("-n")) {
            miniInsertionSize = std::stoi(inputParser.getCmdOption("-n"));
            if (miniInsertionSize <= 0) {
                std::cout << "parameter of -n should be a positive value" << std::endl;
                return 1;
            }
        }

        if (inputParser.cmdOptionExists("-m")) {
            maxDistance = std::stoi(inputParser.getCmdOption("-m"));
            if (maxDistance <= 0) {
                std::cout << "parameter of -m should be a positive value" << std::endl;
                return 1;
            }
        }

        if (inputParser.cmdOptionExists("-w")) {
            windownWidth = std::stoi(inputParser.getCmdOption("-w"));
        }

        if (inputParser.cmdOptionExists("-B")) {
            mismatchingPenalty = std::stoi(inputParser.getCmdOption("-B"));
            if (mismatchingPenalty >= 0) {
                std::cout << "parameter of B should be a negative value" << std::endl;
                return 1;
            }
        }

        if (inputParser.cmdOptionExists("-O1")) {
            openGapPenalty1 = std::stoi(inputParser.getCmdOption("-O1"));
            if (openGapPenalty1 >= 0) {
                std::cout << "parameter of O1 should be a negative value" << std::endl;
                return 1;
            }
        }

        if (inputParser.cmdOptionExists("-E1")) {
            extendGapPenalty1 = std::stoi(inputParser.getCmdOption("-E1"));
            if (extendGapPenalty1 >= 0) {
                std::cout << "parameter of E1 should be a negative value" << std::endl;
                return 1;
            }
        }

        if (inputParser.cmdOptionExists("-O2")) {
            openGapPenalty2 = std::stoi(inputParser.getCmdOption("-O2"));
            if (openGapPenalty2 >= 0) {
                std::cout << "parameter of O1 should be a negative value" << std::endl;
                return 1;
            }
        }

        if (inputParser.cmdOptionExists("-E2")) {
            extendGapPenalty2 = std::stoi(inputParser.getCmdOption("-E2"));
            if (extendGapPenalty2 > 0) {
                std::cout << "parameter of E1 should be a negative value" << std::endl;
                return 1;
            }
        }

        std::vector<BlocksForMsa> ref1Ref2BlocksForMsas;
        readMafForMsa(ref1Ref2Maf, ref1Ref2BlocksForMsas);

        std::vector<BlocksForMsa> ref1QueryBlocksForMsas;
        readMafForMsa(ref1QueryMaf, ref1QueryBlocksForMsas);

        std::vector<BlocksForMsa> ref2QueryBlocksForMsas;
        readMafForMsa(ref2QueryMaf, ref2QueryBlocksForMsas);

        std::map<std::string, std::string> reference1Genome;
        readFastaFile(reference1GenomeSequence, reference1Genome);

        std::map<std::string, std::string> reference2Genome;
        readFastaFile(reference2GenomeSequence, reference2Genome);

        ancestorInversion(ref1Ref2BlocksForMsas, ref1QueryBlocksForMsas, ref2QueryBlocksForMsas);
        ancestorLink(ref1Ref2BlocksForMsas, ref1QueryBlocksForMsas, ref2QueryBlocksForMsas); //for this dataset, there is relocation, so no need to run this runction

        generateMsa(ref1Ref2BlocksForMsas, ref1QueryBlocksForMsas, ref2QueryBlocksForMsas, reference1Genome, reference2Genome,
                    matchingScore, mismatchingPenalty, openGapPenalty1, extendGapPenalty1,
                    openGapPenalty2, extendGapPenalty2, windownWidth, wfaSize,
                    min_wavefront_length, max_distance_threshold, miniInsertionSize, maxDistance);
        outputAncestral(ref1Ref2BlocksForMsas, ref1QueryBlocksForMsas, ref2QueryBlocksForMsas, reference1Genome, reference2Genome, outPutFile);

        return 0;
    } else {
        std::cerr << usage.str();
    }

    return 0;
}


// the following functions were developped for evaluation aim. some of them have hard codes and or output file might have compatible problems with other applications
int maf2vcf(int argc, char **argv, std::map<std::string, std::string> &parameters) {
    std::stringstream usage;
    usage << "Usage: " << PROGRAMNAME
          << " maf2vcf -r refGenome -m mafFile -o output " << std::endl <<
          "Options" << std::endl <<
          " -h           produce help message" << std::endl <<
          " -o   FILE    output file" << std::endl <<
          " -r   FILE    reference genome sequence" << std::endl <<
          " -m   FILE    input file in maf format" << std::endl <<
          " -O   STRING  VCF/GVCF" << std::endl <<
          std::endl;

    InputParser inputParser(argc, argv);
    if (inputParser.cmdOptionExists("-h") || inputParser.cmdOptionExists("--help")) {
        std::cerr << usage.str();
    } else if (inputParser.cmdOptionExists("-r") && inputParser.cmdOptionExists("-m") &&
               inputParser.cmdOptionExists("-o")) {
        std::string fastaFilePath = inputParser.getCmdOption("-r");
        std::string outputovcffile = inputParser.getCmdOption("-o");
        std::string mafFile = inputParser.getCmdOption("-m");
        bool gvcf = false;
        if (inputParser.cmdOptionExists("-O")) {
            if (inputParser.getCmdOption("-O").compare("VCF") == 0) {

            } else if (inputParser.getCmdOption("-O").compare("GVCF") == 0) {
                gvcf = true;
            } else {
                std::cerr << "the value of parameter O should be VCF or GVCF" << std::endl;
                return 1;
            }
        }
        mafTovcf(mafFile, fastaFilePath, outputovcffile, gvcf);
    } else {
        std::cerr << usage.str();
    }
    return 0;
}

int sam2vcf(int argc, char **argv, std::map<std::string, std::string> &parameters) {
    std::stringstream usage;
    int32_t range = 30;
    usage << "Usage: " << PROGRAMNAME
          << " maf2vcf -r refGenome -m mafFile -o output " << std::endl <<
          "Options" << std::endl <<
          " -h           produce help message" << std::endl <<
          " -s   FILE    input file in sam format" << std::endl <<
          " -r   FILE    reference genome sequence" << std::endl <<
          " -q   FILE    query genome sequence" << std::endl <<
          " -d   INT     range of interval to output (default: " << range << ")" << std::endl <<
          " -o   FILE    output file" << std::endl << std::endl;

    InputParser inputParser(argc, argv);
    if (inputParser.cmdOptionExists("-h") || inputParser.cmdOptionExists("--help")) {
        std::cerr << usage.str();
    } else if (inputParser.cmdOptionExists("-r") && inputParser.cmdOptionExists("-s") &&
               inputParser.cmdOptionExists("-o") && inputParser.cmdOptionExists("-q")) {
        std::string refGenomeFile = inputParser.getCmdOption("-r");
        std::string queryGenomeFile = inputParser.getCmdOption("-q");
        std::string outputovcffile = inputParser.getCmdOption("-o");
        if (inputParser.cmdOptionExists("-d")) {
            range = std::stoi(inputParser.getCmdOption("-d"));
        }
        std::string samFile = inputParser.getCmdOption("-s");
        samToVcf(samFile, refGenomeFile, queryGenomeFile, range, outputovcffile);
    } else {
        std::cerr << usage.str();
    }
    return 0;
}

int sam2maf(int argc, char **argv, std::map<std::string, std::string> &parameters) {
    std::stringstream usage;
    usage << "Usage: " << PROGRAMNAME
          << " sam2maf -r refGenome -q queryGenome -s samFile -o output " << std::endl <<
          "Options" << std::endl <<
          " -h           produce help message" << std::endl <<
          " -o   FILE    output file" << std::endl <<
          " -r   FILE    reference genome sequence" << std::endl <<
          " -q   FILE    query genome sequence" << std::endl <<
          " -s   FILE    input file in sam format" << std::endl <<
          std::endl;

    InputParser inputParser(argc, argv);
    if (inputParser.cmdOptionExists("-h") || inputParser.cmdOptionExists("--help")) {
        std::cerr << usage.str();
    } else if (inputParser.cmdOptionExists("-r") && inputParser.cmdOptionExists("-s") &&
               inputParser.cmdOptionExists("-o") && inputParser.cmdOptionExists("-q")) {
        std::string referenceFastaFilePath = inputParser.getCmdOption("-r");
        std::string outputFilePath = inputParser.getCmdOption("-o");
        std::string queryFastaFilePath = inputParser.getCmdOption("-q");
        std::string samFilePath = inputParser.getCmdOption("-s");
        samToMaf(samFilePath, referenceFastaFilePath, queryFastaFilePath, outputFilePath);
    } else {
        std::cerr << usage.str();
    }
    return 0;
}


int evaluateTEAlignment(int argc, char **argv, std::map<std::string, std::string> &parameters) {
    std::stringstream usage;
    usage << "Usage: " << PROGRAMNAME
          << " evaluateTEAlignment -c chromosome -r refGenome -v vcfFile -g TEannotation -o output " << std::endl <<
          "Options" << std::endl <<
          " -h           produce help message" << std::endl <<
          " -c   chr     which chromosome to compare file" << std::endl <<
          " -o   FILE    output file" << std::endl <<
          " -r   FILE    reference genome sequence" << std::endl <<
          " -v   FILE    input vcf file" << std::endl <<
          " -g   FILE    TE annotation file in gff format" << std::endl <<
          std::endl;

    InputParser inputParser(argc, argv);
    if (inputParser.cmdOptionExists("-h") || inputParser.cmdOptionExists("--help")) {
        std::cerr << usage.str();
    } else if (inputParser.cmdOptionExists("-c") && inputParser.cmdOptionExists("-r") &&
               inputParser.cmdOptionExists("-o") && inputParser.cmdOptionExists("-v") && inputParser.cmdOptionExists("-g")) {
        std::string chr = inputParser.getCmdOption("-c");
        std::string fastaFilePath = inputParser.getCmdOption("-r");
        std::map<std::string, std::string> referenceGenome;
        readFastaFile(fastaFilePath, referenceGenome);
        std::cout << "genome reading done" << std::endl;
        std::string outputFilePath = inputParser.getCmdOption("-o");

        std::ofstream ofile;

        ofile.open(outputFilePath);
        std::string vcfFilePath = inputParser.getCmdOption("-v");

        std::map<std::string, std::vector<Variant>> variants;
        vcfToVariant(vcfFilePath, variants, chr);
        std::cout << "vcf to variant done" << std::endl;

        std::string gffFile = inputParser.getCmdOption("-g");
        std::vector<Variant> benchmarkVariants;
        gffToVariant(fastaFilePath, gffFile, chr, benchmarkVariants);

        std::cout << "gff to variant done" << std::endl;
        for (Variant v: benchmarkVariants) {
            if (variantWith(v, variants, referenceGenome)) {
                ofile << "good\t" << v.getChromosome() << "\t" << v.getPosition() << "\t" << v.getChanginglength() << "\t" + v.getReference() << "\t" << v.getAlternative() << std::endl;
            } else {
                ofile << "bad\t" << v.getChromosome() << "\t" << v.getPosition() << "\t" << v.getChanginglength() << "\t" + v.getReference() << "\t" << v.getAlternative() << std::endl;
            }
        }
        ofile.close();
    } else {
        std::cerr << usage.str();
    }
    return 0;
}

int sdiToMaf(int argc, char **argv, std::map<std::string, std::string> &parameters) {
    std::stringstream usage;
    usage << "Usage: " << PROGRAMNAME
          << " sdiToMaf -s sdiFile -r refGenome -q syntheticGenome -o output mafFile " << std::endl <<
          "Options" << std::endl <<
          " -h           produce help message" << std::endl <<
          " -o   FILE    output file" << std::endl <<
          " -r   FILE    reference genome sequence" << std::endl <<
          " -s   FILE    sdi file" << std::endl <<
          " -q   FILE    synthetic genome sequence" << std::endl <<
          std::endl;

    InputParser inputParser(argc, argv);
    if (inputParser.cmdOptionExists("-h") || inputParser.cmdOptionExists("--help")) {
        std::cerr << usage.str();
    }
    else if (inputParser.cmdOptionExists("-s") && inputParser.cmdOptionExists("-r") &&
               inputParser.cmdOptionExists("-o") && inputParser.cmdOptionExists("-q")) {
        std::string fastaFilePath = inputParser.getCmdOption("-r");
        std::string targetFastaFilePath = inputParser.getCmdOption("-q");
        std::string sdiFile = inputParser.getCmdOption("-s");
        std::string outfile = inputParser.getCmdOption("-o");
        sdiToMaf(fastaFilePath, targetFastaFilePath, sdiFile, outfile);
    }
    else {
        std::cerr << usage.str();
    }

    return 0;
}


int ali(int argc, char **argv, std::map<std::string, std::string> &parameters) {

    int32_t matchingScore = 0;
    int32_t mismatchingPenalty = -6;
    int32_t openGapPenalty1 = -8;
    int32_t extendGapPenalty1 = -2;

    int32_t openGapPenalty2 = -75;
    int32_t extendGapPenalty2 = -1;
    int64_t windowWidth = 38000;

    std::stringstream usage;
    usage << "Usage: " << PROGRAMNAME
          << " ali -r refSeq.fa -s querySeq.fa"
          << std::endl <<
          "Options" << std::endl <<
          " -h           produce help message" << std::endl <<
          " -r   FILE    reference sequence (single sequence in FASTA format)" << std::endl <<
          " -s   FILE    target sequence (single sequence in FASTA format)" << std::endl <<
          " -w   INT     sequence alignment window width (default: " << windowWidth << ")" << std::endl <<
          " -B   INT     mismatching penalty (default: " << mismatchingPenalty << ")" << std::endl <<
          " -O1  INT     open gap penalty (default: " << openGapPenalty1 << ")" << std::endl <<
          " -E1  INT     extend gap penalty (default: " << extendGapPenalty1 << ")" << std::endl <<
          " -O2  INT     open gap penalty 2 (default: " << openGapPenalty2 << ")" << std::endl <<
          " -E2  INT     extend gap penalty 2 (default: " << extendGapPenalty2 << ")" << std::endl << std::endl;

    InputParser inputParser(argc, argv);
    if (inputParser.cmdOptionExists("-h") || inputParser.cmdOptionExists("--help")) {
        std::cerr << usage.str();
    } else if (inputParser.cmdOptionExists("-r") && inputParser.cmdOptionExists("-s")) {

        std::string referenceGenomeSequence = inputParser.getCmdOption("-r");
        std::string targetGenomeSequence = inputParser.getCmdOption("-s");

        if (inputParser.cmdOptionExists("-w")) {
            windowWidth = std::stoi(inputParser.getCmdOption("-w"));
        }

        if (inputParser.cmdOptionExists("-B")) {
            mismatchingPenalty = std::stoi(inputParser.getCmdOption("-B"));
            if (mismatchingPenalty >= 0) {
                std::cout << "parameter of B should be a negative value" << std::endl;
                return 1;
            }
        }

        if (inputParser.cmdOptionExists("-O1")) {
            openGapPenalty1 = std::stoi(inputParser.getCmdOption("-O1"));
            if (openGapPenalty1 >= 0) {
                std::cout << "parameter of O1 should be a negative value" << std::endl;
                return 1;
            }
        }
        if (inputParser.cmdOptionExists("-E1")) {
            extendGapPenalty1 = std::stoi(inputParser.getCmdOption("-E1"));
            if (extendGapPenalty1 >= 0) {
                std::cout << "parameter of E1 should be a negative value" << std::endl;
                return 1;
            }
        }

        if (inputParser.cmdOptionExists("-O2")) {
            openGapPenalty2 = std::stoi(inputParser.getCmdOption("-O2"));
            if (openGapPenalty2 >= 0) {
                std::cout << "parameter of O1 should be a negative value" << std::endl;
                return 1;
            }
        }
        if (inputParser.cmdOptionExists("-E2")) {
            extendGapPenalty2 = std::stoi(inputParser.getCmdOption("-E2"));
            if (extendGapPenalty2 > 0) {
                std::cout << "parameter of E1 should be a negative value" << std::endl;
                return 1;
            }
        }

        std::map<std::string, std::string> referenceSeq;
        readFastaFile(referenceGenomeSequence, referenceSeq);

        std::map<std::string, std::string> querySeq;
        readFastaFile(targetGenomeSequence, querySeq);

        if (referenceSeq.size() != 1) {
            std::cerr << "There should be one and only one sequence in the reference FASTA file" << std::endl;
        }

        if (querySeq.size() != 1) {
            std::cerr << "There should be one and only one sequence in the query FASTA file" << std::endl;
        }

        std::string _alignment_q;
        std::string _alignment_d;

        int32_t min_wavefront_length = 20;
        int32_t max_distance_threshold = 100;
        int32_t wfaSize = 15000;
        Scorei m(matchingScore, mismatchingPenalty);
        std::string refSeqStr = referenceSeq.begin()->second;
        std::string querySeqStr = querySeq.begin()->second;
        int64_t thiScore = alignSlidingWindow(querySeqStr, refSeqStr, _alignment_q, _alignment_d,
                                              windowWidth, wfaSize, matchingScore, mismatchingPenalty, openGapPenalty1,
                                              extendGapPenalty1, openGapPenalty2, extendGapPenalty2,
                                              min_wavefront_length, max_distance_threshold, m, parameters);
        std::cout << ">" << referenceSeq.begin()->first << std::endl;
        std::cout << _alignment_d << std::endl;
        std::cout << ">" << querySeq.begin()->first << std::endl;
        std::cout << _alignment_q << std::endl;

        return 0;
    } else {
        std::cerr << usage.str();
    }

    return 0;
}

